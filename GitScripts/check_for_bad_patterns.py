#!/usr/bin/env python3

# A script which takes in a unified diff expected to be generated by
# git diff -U0 | grep '^[+@]'
# and outputs any bad pattern matches. See documentation of
# BadPattern.to_comment() for details of output format.

import sys
import re
import fileinput
from enum import Enum


class Level(Enum):
    """
    Severity level of a bad pattern.
    """

    INFO = 1
    WARN = 2
    ERROR = 3


# Extensions that a pattern will be applied to by default.
DEFAULT_EXTENSIONS = ["cs"]


class BadPattern:
    """
    A pattern within a file that must be avoided.
    """

    def __init__(
        self,
        regex,
        message,
        extensions=DEFAULT_EXTENSIONS,
        suggestion=None,
        level=Level.INFO,
    ):
        """
        Takes a compiled regular expression `regex` that is checked against
        every line within changed files having an extension contained in
        `extensions`, a `message` that shall be displayed to the user in case
        a match has been found, a regex substitution `suggestion` for a found
        bad pattern, and a severity `level`.
        """
        self.regex = regex
        self.message = message
        self.extensions = extensions
        self.suggestion = suggestion
        self.level = level

    def to_comment(self, filename: str, line_number: int, suggestion: str) -> str:
        """
        Turns this bad pattern match into a string containing the following
        components, separated by newlines:
        Filename of matched file, line number where match occurred,
        set message, set level, set regular expression, substituted
        suggestion (may be empty)
        """
        return (
            f"{filename}\n{line_number}\n{self.message}\n{self.level}\n{self.regex.pattern}\n"
            + suggestion
        )


# *** MODIFY BELOW TO ADD NEW BAD PATTERNS ***

BAD_PATTERNS = [
    BadPattern(
        re.compile(r"^(.*(?<!= )new \w*NetAction\w*\([^()]*\))([^.].*)$"),
        "Don't forget to call `.Execute()` on newly created net actions!",
        suggestion=r"\1.Execute()\2",
        level=Level.ERROR,
    ),
    # FIXME: Remove the ones below, they are just for testing purposes.
    BadPattern(
        re.compile(r"^BAD([_A-Z]*\s*=\s*\[.*)$"),
        "So long, and thanks for all the fish.",
        suggestion=r"RAD\1",
        extensions=["py"],
        level=Level.WARN,
    ),
    BadPattern(
        re.compile(r"^\s*re\.compile\(r\"\^\\s\*re\\\.compile.*$"),
        "A recursive check for this testing example, why not.",
        extensions=["py"],
        level=Level.INFO,
    ),
]

# *** MODIFY ABOVE TO ADD NEW BAD PATTERNS ***


def handle_chunk(open_diff, start_line, filename, lines) -> int:
    """
    Handles a single chunk of a unified diff and checks it against
    any bad patterns, printing comments for any matches it finds.
    """
    extension = filename.rsplit(".", 1)[1] if "." in filename else ""
    occurrences = 0
    for i in range(lines):
        chunk_line = open_diff.readline().rstrip()
        for pattern in BAD_PATTERNS:
            if extension in pattern.extensions and pattern.regex.match(
                # The first character in chunk_line is +. We skip it.
                chunk_line[1:]
            ):
                # We found a bad pattern.
                occurrences += 1
                # Try getting suggestion, if one exists.
                if pattern.suggestion:
                    suggestion = pattern.regex.sub(pattern.suggestion, chunk_line[1:])
                else:
                    suggestion = ""
                print(pattern.to_comment(filename, start_line + i, suggestion))
    return occurrences


def main():
    print("Checking for bad patterns by reading the diff from stdin...")
    occurrences = 0
    with fileinput.input(encoding="utf-8") as diff:
        current_file = None
        chunk_indicator = re.compile(r"^@@ -[0-9,]* \+(\d*)(?:,(\d*))? @@.*$")
        while line := diff.readline().rstrip():
            if line.startswith("+++"):
                # Start of a new file.
                current_file = line.split("/", 1)[1]
            elif line.startswith("@@"):
                # Start of a new chunk.
                start_line, line_count = chunk_indicator.match(line).group(1, 2)
                # We pass the diff object so that `handle_chunk` can advance lines.
                occurrences += handle_chunk(
                    diff,
                    int(start_line),
                    current_file,
                    1 if line_count is None else int(line_count),
                )
    sys.exit(min(occurrences, 255))


if __name__ == "__main__":
    main()
