package de.unibremen.swt.see.manager.service;

import com.github.dockerjava.api.DockerClient;
import com.github.dockerjava.api.command.CreateContainerResponse;
import com.github.dockerjava.api.command.CreateVolumeResponse;
import com.github.dockerjava.api.command.InspectContainerResponse;
import com.github.dockerjava.api.command.InspectVolumeResponse;
import com.github.dockerjava.api.exception.NotFoundException;
import com.github.dockerjava.api.exception.NotModifiedException;
import com.github.dockerjava.api.model.Bind;
import com.github.dockerjava.api.model.ExposedPort;
import com.github.dockerjava.api.model.HostConfig;
import com.github.dockerjava.api.model.PortBinding;
import com.github.dockerjava.api.model.Ports;
import com.github.dockerjava.api.model.Volume;
import com.github.dockerjava.core.DefaultDockerClientConfig;
import com.github.dockerjava.core.DockerClientConfig;
import com.github.dockerjava.core.DockerClientImpl;
import com.github.dockerjava.transport.DockerHttpClient;
import com.github.dockerjava.zerodep.ZerodepDockerHttpClient;
import de.unibremen.swt.see.manager.model.Server;
import de.unibremen.swt.see.manager.model.ServerStatusType;
import static de.unibremen.swt.see.manager.model.ServerStatusType.ERROR;
import static de.unibremen.swt.see.manager.model.ServerStatusType.ONLINE;
import static de.unibremen.swt.see.manager.model.ServerStatusType.STARTING;
import static de.unibremen.swt.see.manager.model.ServerStatusType.STOPPING;
import jakarta.annotation.PostConstruct;
import java.io.IOException;
import java.net.URISyntaxException;
import java.nio.file.Path;
import java.time.Duration;
import java.util.Map;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;

/**
 * Service class for managing container-related operations.
 * <p>
 * This service provides high-level operations for container management,
 * including creating, retrieving, updating, and deleting containers. It
 * encapsulates the business logic and acts as an intermediary between the
 * controller layer and the data access layer.
 * <p>
 * Container instances are managed by the {@link ServerService}.
 *
 * @see ServerService
 */
@Service
@Transactional
@Slf4j
@RequiredArgsConstructor
public class ContainerService {

    /**
     * Used to access server files.
     */
    private final FileService fileService;

    /**
     * Used to spawn and control containers.
     */
    private DockerClient dockerClient;

    /**
     * The URI used to connect to the Docker instance.
     * <p>
     * Possible formats are usually either {@code tcp://host:port} or
     * {@code unix:///path/to.sock}.
     */
    @Value("${see.app.docker.host}")
    private String dockerHost;

    /**
     * Contains the domain name, or IP address, and port of this back-end
     * application server.
     */
    @Value("${see.app.backend.domain}")
    private String backendDomain;

    /**
     * The name of the container image that should be used to run game server
     * instances.
     */
    @Value("${see.app.docker.image.gameserver}")
    private String containerImageName;

    /**
     * The path where the multiplayer data are mounted in a game server
     * container.
     */
    final static String CONTAINER_VOLUME_PATH = "/multiplayer_data/";

    /**
     * The port that the game server exposes inside the container.
     * <p>
     * This port will be mapped to the server's external port on the container
     * host.
     */
    final static int CONTAINER_PORT = 7777;

    /**
     * Does custom initialization after the service has been constructed.
     * <p>
     * The constructor is generated by Lombok via
     * {@code @RequiredArgsConstructor}. This method is used to do additional
     * initialization steps usually implemented in a constructor.
     * <p>
     * Initializes the {@code DockerClient}.
     *
     * @throws URISyntaxException if the Docker {@code URI} is malformed
     */
    @PostConstruct
    public void init() throws URISyntaxException {
        DockerClientConfig config = DefaultDockerClientConfig.createDefaultConfigBuilder()
                .withDockerHost(dockerHost)
                .build();

        DockerHttpClient httpClient = new ZerodepDockerHttpClient.Builder()
                .dockerHost(config.getDockerHost())
                .maxConnections(100)
                .connectionTimeout(Duration.ofSeconds(30))
                .responseTimeout(Duration.ofSeconds(45))
                //                .sslConfig(sslConfig)
                .build();

        this.dockerClient = DockerClientImpl.getInstance(config, httpClient);

        try {
            dockerClient.pingCmd().exec();
            log.info("Successfully connected to Docker at: {}", dockerHost);
        } catch (Exception e) {
            log.warn("Connection to Docker failed with URI: {}", dockerHost);
        }
    }

    /**
     * Starts a container for the given server.
     *
     * @param server the server configuration
     * @throws java.io.IOException if the uploaded files for given server cannot
     * be accessed
     * @throws IllegalStateException if the server is busy or already running
     */
    public void startContainer(Server server) throws IOException {
        switch (server.getServerStatusType()) {
            case ONLINE ->
                throw new IllegalStateException("Server is already running!");
            case STARTING ->
                throw new IllegalStateException("Server is already starting!");
            case STOPPING ->
                throw new IllegalStateException("Server is stopping!");
            case ERROR ->
                throw new IllegalStateException("Server is in ERROR state!");
        }

        final String containerName = "see-" + server.getId();
        final String volumeName = "see-data-" + server.getId();
        String containerId = server.getContainerId();

        if (containerId == null || !containerExists(containerId)) {
            if (!volumeExists(volumeName)) {
                createVolume(server, volumeName);
                log.debug("Created new volume: {}", volumeName);
            }
            CreateContainerResponse containerResponse = createContainer(containerName, volumeName, server.getContainerPort(), server.getId().toString(), server.getServerPassword());
            containerId = containerResponse.getId();
            log.info("Created new container: {}", containerName);
        }

        try {
            dockerClient.startContainerCmd(containerId).exec();
            log.info("Started existing container: {}", containerName);
        } catch (NotModifiedException e) {
            log.warn("Container already running: {}", containerName);
        }

        server.setContainerId(containerId);
        server.setContainerVolume(volumeName);
        server.setServerStatusType(ServerStatusType.ONLINE);
    }

    /**
     * Stops the container for the given server.
     *
     * @param server the server configuration
     * @throws IllegalStateException if the server is busy or already stopped
     */
    public void stopContainer(Server server) {
        switch (server.getServerStatusType()) {
            case OFFLINE ->
                throw new IllegalStateException("Server is already stopped!");
            case STARTING ->
                throw new IllegalStateException("Server is starting!");
            case STOPPING ->
                throw new IllegalStateException("Server is already stopping!");
            case ERROR ->
                throw new IllegalStateException("Server is in ERROR state!");
        }

        server.setServerStatusType(ServerStatusType.STOPPING);
        try {
            dockerClient.stopContainerCmd(server.getContainerId()).exec();
        } catch (NotFoundException e) {
            log.warn("Container to stop does not exist for server {}", server.getId());
            server.setContainerId(null);
        }

        server.setServerStatusType(ServerStatusType.OFFLINE);
    }

    /**
     * Deletes a container and its volume.
     *
     * @param server the server configuration
     * @throws IllegalStateException if the server is busy or running
     */
    public void deleteContainer(Server server) {
        String containerId = server.getContainerId();
        if (containerId == null) {
            return;
        }

        try {
            try {
                dockerClient.stopContainerCmd(containerId).exec();
            } catch (NotModifiedException e) {
                // Server already stopped
            }
            dockerClient.removeContainerCmd(containerId)
                    .withForce(true)
                    .exec();
            dockerClient.removeVolumeCmd(server.getContainerVolume()).exec();
        } catch (NotFoundException e) {
            log.warn("Container to delete does not exist for server {}", server.getId());
        }

        server.setContainerPort(null);
        server.setContainerId(null);
        server.setContainerVolume(null);
    }

    /**
     * Checks if a container is running for given server.
     *
     * @param server the server configuration
     * @return {@code true} if a container is running for the server, else
     * {@code false}.
     */
    public boolean isRunning(Server server) {
        InspectContainerResponse containerInfo = getContainerInfo(server);
        return containerInfo != null && containerInfo.getState().getRunning();
    }

    /**
     * Checks if a container exists for given server.
     *
     * @param server the server configuration
     * @return {@code true} if a container exists for the server, else
     * {@code false}.
     */
    public boolean hasContainer(Server server) {
        return getContainerInfo(server) != null;
    }

    /**
     * Gets the container information for given server.
     *
     * @param server the server configuration
     * @return the container info if a container exists, or {@code null}
     */
    private InspectContainerResponse getContainerInfo(Server server) {
        String containerId = server.getContainerId();
        if (containerId == null || containerId.isBlank()) {
            return null;
        }

        try {
            return dockerClient.inspectContainerCmd(containerId).exec();
        } catch (NotFoundException e) {
            return null;
        }
    }

    /**
     * Creates and starts a new SEE container.
     *
     * @param containerName the name that the container should be started under
     * @param volumeName the name of an existing volume with the shared files
     * for a SEE Code City
     * @param port the port number that should be exposed on the container host
     * @return response metadata object
     */
    private CreateContainerResponse createContainer(final String containerName, final String volumeName, final int port, final String serverId, final String password) {
        ExposedPort exposedPort = ExposedPort.tcp(CONTAINER_PORT);
        PortBinding portBinding = new PortBinding(Ports.Binding.bindPort(port), exposedPort);

        return dockerClient.createContainerCmd(containerImageName)
                .withName(containerName)
                .withHostConfig(HostConfig.newHostConfig()
                        .withBinds(new Bind(volumeName, new Volume(CONTAINER_VOLUME_PATH)))
                        .withPortBindings(portBinding)
                )
                .withExposedPorts(exposedPort)
                .withEnv("SEE_BACKEND_DOMAIN=" + backendDomain)
                .withEnv("SEE_SERVER_ID=" + serverId)
                .withEnv("SEE_SERVER_PASSWORD=" + password)
                .exec();
    }

    /**
     * Checks if a container with given ID exists.
     *
     * @param containerId the ID of the container
     * @return {@code true} if the container exists, else {@code false}
     */
    private boolean containerExists(final String containerId) {
        if (containerId == null) {
            return false;
        }

        try {
            InspectContainerResponse containerResponse = dockerClient.inspectContainerCmd(containerId).exec();
            return containerResponse != null;
        } catch (NotFoundException e) {
            return false;
        }
    }

    /**
     * Prepares a container volume for given server instance.
     * <p>
     * Creates a new container volume under given name with the Code City files
     * from given server instance. This uses the files from the upload directory
     * directly but keeps them read-only so that they are managed from outside
     * the container.
     *
     * @param server the server that the volume should be created for
     * @param volumeName the name under which the volume should be created
     * @throws IOException if there is a problem accessing the server's upload
     * directory
     */
    private CreateVolumeResponse createVolume(Server server, final String volumeName) throws IOException {
        log.debug("Creating new volume: {}", volumeName);
        Path uploadDir = fileService.getUploadPath(server);
        return dockerClient.createVolumeCmd()
                .withName(volumeName)
                .withDriver("local")
                .withDriverOpts(Map.of(
                        "type", "none",
                        "device", uploadDir.toString(),
                        "o", "bind,ro"
                ))
                .exec();
    }

    /**
     * Checks if a container volume with given name exists.
     *
     * @param volumeName the name of the container volume
     * @return {@code true} if the volume exists, else {@code false}
     */
    private boolean volumeExists(final String volumeName) {
        try {
            InspectVolumeResponse volumeResponse = dockerClient.inspectVolumeCmd(volumeName).exec();
            return volumeResponse != null;
        } catch (NotFoundException e) {
            return false;
        }
    }
}
