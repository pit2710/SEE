package de.unibremen.swt.see.manager.service;

import com.github.dockerjava.api.DockerClient;
import com.github.dockerjava.api.command.CreateContainerResponse;
import com.github.dockerjava.api.command.InspectContainerResponse;
import com.github.dockerjava.api.exception.NotFoundException;
import com.github.dockerjava.api.model.Bind;
import com.github.dockerjava.api.model.ExposedPort;
import com.github.dockerjava.api.model.HostConfig;
import com.github.dockerjava.api.model.PortBinding;
import com.github.dockerjava.api.model.Ports;
import com.github.dockerjava.api.model.Volume;
import com.github.dockerjava.core.DefaultDockerClientConfig;
import com.github.dockerjava.core.DockerClientConfig;
import com.github.dockerjava.core.DockerClientImpl;
import com.github.dockerjava.transport.DockerHttpClient;
import com.github.dockerjava.zerodep.ZerodepDockerHttpClient;
import de.unibremen.swt.see.manager.model.Config;
import de.unibremen.swt.see.manager.model.File;
import de.unibremen.swt.see.manager.model.Server;
import de.unibremen.swt.see.manager.model.ServerStatusType;
import static de.unibremen.swt.see.manager.model.ServerStatusType.ERROR;
import static de.unibremen.swt.see.manager.model.ServerStatusType.ONLINE;
import static de.unibremen.swt.see.manager.model.ServerStatusType.STARTING;
import static de.unibremen.swt.see.manager.model.ServerStatusType.STOPPING;
import de.unibremen.swt.see.manager.repository.ConfigRepository;
import jakarta.annotation.PostConstruct;
import java.net.URISyntaxException;
import java.time.Duration;
import java.util.List;
import java.util.Optional;
import java.util.Random;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;

/**
 * Service class for managing container-related operations.
 * <p>
 * This service provides high-level operations for container management,
 * including creating, retrieving, updating, and deleting containers. It
 * encapsulates the business logic and acts as an intermediary between the
 * controller layer and the data access layer.
 * <p>
 * Container instances are managed by the {@link ServerService}.
 *
 * @see ServerService
 */
@Service
@Transactional
@Slf4j
@RequiredArgsConstructor
public class ContainerService {

    /**
     * Used to access the back-end configuration.
     */
    private final ConfigRepository configRepo;
    /**
     * Used to access server files.
     */
    private final FileService fileService;

    /**
     * Used for the random port generation.
     */
    private final Random random = new Random();

    /**
     * Used to spawn and control containers.
     */
    private DockerClient dockerClient;

    /**
     * The URI used to connect to the Docker instance.
     * <p>
     * Possible formats are usually either {@code tcp://host:port} or
     * {@code unix:///path/to.sock}.
     */
    @Value("${see.app.docker.host}")
    private String dockerHost;

    final static String CONTAINER_VOLUME_PATH = "/app/gameserver_Data/StreamingAssets/Multiplayer/";
    final static int CONTAINER_PORT = 123; // TODO

    /**
     * Does custom initialization after the service has been constructed.
     * <p>
     * The constructor is generated by Lombok via
     * {@code @RequiredArgsConstructor}. This method is used to do additional
     * initialization steps usually implemented in a constructor.
     * <p>
     * Initializes the {@code DockerClient}.
     *
     * @throws URISyntaxException if the Docker {@code URI} is malformed
     */
    @PostConstruct
    public void init() throws URISyntaxException {
        DockerClientConfig config = DefaultDockerClientConfig.createDefaultConfigBuilder()
                .withDockerHost(dockerHost)
                .build();

        DockerHttpClient httpClient = new ZerodepDockerHttpClient.Builder()
                .dockerHost(config.getDockerHost())
                .maxConnections(100)
                .connectionTimeout(Duration.ofSeconds(30))
                .responseTimeout(Duration.ofSeconds(45))
                //                .sslConfig(sslConfig)
                .build();

        this.dockerClient = DockerClientImpl.getInstance(config, httpClient);

        try {
            dockerClient.pingCmd().exec();
        } catch (Exception e) {
            log.warn("Connection to Docker failed with URI: {}", dockerHost);
        }
    }

    /**
     * Starts a container for the given server.
     *
     * @param server the server configuration
     * @throws IllegalStateException if the server is busy or already running
     */
    public void startContainer(Server server) {
        final Config config = resolveConfig();
        List<File> files = fileService.getByServer(server);

        switch (server.getServerStatusType()) {
            case ONLINE ->
                throw new IllegalStateException("Server is already running!");
            case STARTING ->
                throw new IllegalStateException("Server is already starting!");
            case STOPPING ->
                throw new IllegalStateException("Server is stopping!");
            case ERROR ->
                throw new IllegalStateException("Server is in ERROR state!");
        }

        final String containerName = "see-" + server.getId();
        final String volumeName = "see-data-" + server.getId();
        final int port = getRandomPort(config.getMinContainerPort(), config.getMaxContainerPort());

        // TODO Check if container exists and start it, else create new

        // TODO Prepare volume with Code City files
        // Check if volume exists
        //for (File file : files) { â€¦ }
        // TODO: Handle ZIP file in container
        dockerClient.createVolumeCmd()
                .withName(volumeName)
                .exec();

        ExposedPort exposedPort = ExposedPort.tcp(CONTAINER_PORT);
        PortBinding portBinding = new PortBinding(Ports.Binding.bindPort(port), exposedPort);

        // TODO Specify server container image
        CreateContainerResponse container = dockerClient.createContainerCmd("alpine")
                .withName(containerName)
                .withHostConfig(HostConfig.newHostConfig()
                        .withBinds(new Bind(volumeName, new Volume(CONTAINER_VOLUME_PATH)))
                        .withPortBindings(portBinding)
                )
                .withExposedPorts(exposedPort)
                // TODO Specify server configuration
                .withEnv("MY_ENV_VAR=value")
                .withCmd("echo", "hello world")
                .exec();
        final String containerId = container.getId();
        log.info("Started container with ID {}", containerId);

        // Update database entry
        server.setContainerPort(port);
        server.setContainerId(containerId);
        server.setContainerVolume(volumeName);
        server.setServerStatusType(ServerStatusType.ONLINE);
    }

    /**
     * Stops the container for the given server.
     *
     * @param server the server configuration
     * @throws IllegalStateException if the server is busy or already stopped
     */
    public void stopContainer(Server server) {
        switch (server.getServerStatusType()) {
            case OFFLINE ->
                throw new IllegalStateException("Server is already stopped!");
            case STARTING ->
                throw new IllegalStateException("Server is starting!");
            case STOPPING ->
                throw new IllegalStateException("Server is already stopping!");
            case ERROR ->
                throw new IllegalStateException("Server is in ERROR state!");
        }

        server.setServerStatusType(ServerStatusType.STOPPING);
        dockerClient.stopContainerCmd(server.getContainerId());

        server.setServerStatusType(ServerStatusType.OFFLINE);
    }

    /**
     * Deletes a container and its volume.
     *
     * @param server the server configuration
     * @throws IllegalStateException if the server is busy or running
     */
    public void deleteContainer(Server server) {
        dockerClient.stopContainerCmd(server.getContainerId()).exec();
        dockerClient.removeContainerCmd("container_id")
                .withForce(true)
                .exec();
        dockerClient.removeVolumeCmd(server.getContainerVolume()).exec();

        server.setContainerPort(null);
        server.setContainerId(null);
        server.setContainerVolume(null);
    }

    /**
     * Generates a random port in the defined range.
     *
     * @param min lower bound of the port range
     * @param max upper bound of the port range
     * @return random port number
     */
    private int getRandomPort(int min, int max) {
        return random.nextInt(max - min) + min;
    }

    /**
     * Checks if a container is running for given server.
     *
     * @param server the server configuration
     * @return {@code true} if a container is running for the server, else
     * {@code false}.
     */
    public boolean isRunning(Server server) {
        InspectContainerResponse containerInfo = getContainerInfo(server);
        return containerInfo != null && containerInfo.getState().getRunning();
    }

    /**
     * Checks if a container exists for given server.
     *
     * @param server the server configuration
     * @return {@code true} if a container exists for the server, else
     * {@code false}.
     */
    public boolean hasContainer(Server server) {
        return getContainerInfo(server) != null;
    }

    /**
     * Gets the container information for given server.
     *
     * @param server the server configuration
     * @return the container info if a container exists, or {@code null}
     */
    private InspectContainerResponse getContainerInfo(Server server) {
        String containerId = server.getContainerId();
        if (containerId == null || containerId.isBlank()) {
            return null;
        }

        try {
            return dockerClient.inspectContainerCmd(containerId).exec();
        } catch (NotFoundException e) {
            return null;
        }
    }

    /**
     * Resolves the configuration.
     *
     * @return the configuration
     * @throws RuntimeException if the configuration could not be found
     */
    private Config resolveConfig() {
        final Optional<Config> optConfig = configRepo.findConfigById(1);
        if (optConfig.isEmpty()) {
            throw new RuntimeException("Server config could not be found!");
        }
        return optConfig.get();
    }
}
